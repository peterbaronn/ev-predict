# -*- coding: utf-8 -*-
"""EV_PREDICT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vQdbPCUw4SOugFpRqT1YsSH5nPGSZXkJ
"""

# IMPORT & LOAD DATA

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, PolynomialFeatures
from sklearn.metrics import (
    mean_absolute_error, r2_score,
    accuracy_score, classification_report, confusion_matrix
)

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier

from sklearn.cluster import KMeans, DBSCAN
from scipy import stats

# Untuk tampilan plot
sns.set(style="whitegrid")

ev_predic['Charge_Cycles'].sort_values(ascending=False)

# Load dataset
ev_predic = pd.read_csv("EV_Predictive_Maintenance_Dataset_15min.csv")

print("Shape EV Predict:", ev_predic.shape)

display(ev_predic.head())

ev_predic.info()

display(ev_predic.describe())

print("Null values in ev_predic:")
display(ev_predic.isnull().sum())

# Cek duplikasi
print("Duplicated rows in EV Predict:", ev_predic.duplicated().sum())

# Drop duplicates jika ada yg duplicates
ev_predic = ev_predic.drop_duplicates().reset_index(drop=True)

ev_predic["Timestamp"] = pd.to_datetime(ev_predic["Timestamp"], errors="coerce")

# Pilih fitur baterai inti yang akan digunakan
battery_features = [
    "Battery_Temperature",
    "Battery_Voltage",
    "Battery_Current",
    "Power_Consumption",
    "Charge_Cycles"
]

print("Shape after dropping NA on battery features:", ev_predic.shape)

# OUTLIER HANDLING

outlier_cols = [
    "Battery_Temperature",
    "Battery_Voltage",
    "Battery_Current",
    "Power_Consumption",
    "Charge_Cycles"
]

def iqr_filter(df, col):
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    return df[(df[col] >= lower) & (df[col] <= upper)]

# Terapkan IQR filtering (aman, tidak merusak data)
for col in outlier_cols:
    before = ev_predic.shape[0]
    ev_predic = iqr_filter(ev_predic, col)
    after = ev_predic.shape[0]
    print(f"Outlier removed in {col}: {before - after}")

ev_predic = ev_predic.reset_index(drop=True)

print("Shape after outlier handling:", ev_predic.shape)

# BOXPLOT OUTLIERS
plt.figure(figsize=(12,6))
sns.boxplot(data=ev_predic[battery_features], palette="Set2")
plt.title("Boxplot of Battery Features (Outlier Visualization)")
plt.xticks(rotation=45)
plt.show()

# EDA

display(ev_predic[battery_features].describe())

corr_cols = [
    "Battery_Temperature",
    "Battery_Voltage",
    "Battery_Current",
    "Power_Consumption",
    "Charge_Cycles",
    "Health_Score"
]

plt.figure(figsize=(8,6))
sns.heatmap(ev_predic[corr_cols].corr(), annot=True, cmap="Blues")
plt.title("Korelasi Antar Fitur Inti terhadap Health Score")
plt.show()

plt.figure(figsize=(15,6))

plt.subplot(2,3,1)
sns.histplot(ev_predic["Battery_Temperature"], kde=True, color="orange")
plt.title("Distribusi Battery Temperature")

plt.subplot(2,3,2)
sns.histplot(ev_predic["Battery_Voltage"], kde=True, color="blue")
plt.title("Distribusi Battery Voltage")

plt.subplot(2,3,3)
sns.histplot(ev_predic["Battery_Current"], kde=True, color="green")
plt.title("Distribusi Battery Current")

plt.subplot(2,3,4)
sns.histplot(ev_predic["Power_Consumption"], kde=True, color="red")
plt.title("Distribusi Power Consumption")

plt.subplot(2,3,5)
sns.histplot(ev_predic["Charge_Cycles"], kde=True, color="purple")
plt.title("Distribusi Charge Cycles")

plt.tight_layout()
plt.show()

plt.figure(figsize=(15,6))

plt.subplot(2,3,1)
sns.scatterplot(x=ev_predic["Battery_Temperature"], y=ev_predic["Health_Score"])
plt.title("Battery Temperature vs Health Score")

plt.subplot(2,3,2)
sns.scatterplot(x=ev_predic["Battery_Voltage"], y=ev_predic["Health_Score"])
plt.title("Battery Voltage vs Health Score")

plt.subplot(2,3,3)
sns.scatterplot(x=ev_predic["Battery_Current"], y=ev_predic["Health_Score"])
plt.title("Battery Current vs Health Score")

plt.subplot(2,3,4)
sns.scatterplot(x=ev_predic["Power_Consumption"], y=ev_predic["Health_Score"])
plt.title("Power Consumption vs Health Score")

plt.subplot(2,3,5)
sns.scatterplot(x=ev_predic["Charge_Cycles"], y=ev_predic["Health_Score"])
plt.title("Charge Cycles vs Health Score")

plt.tight_layout()
plt.show()

"""### PRA-MODELING"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.cluster import KMeans, DBSCAN

X = ev_predic[battery_features]
y = ev_predic["Health_Score"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

"""### MODELING"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

def evaluate_regression(y_true, y_pred, name="Model"):
    mae  = mean_absolute_error(y_true, y_pred)
    mse  = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2   = r2_score(y_true, y_pred)

    print(f"\n=== EVALUASI {name} ===")
    print(f"MAE  : {mae:.4f}")
    print(f"MSE  : {mse:.4f}")
    print(f"RMSE : {rmse:.4f}")
    print(f"R2   : {r2:.4f}")

"""## Regression"""

# RANDOM FOREST

from sklearn.ensemble import RandomForestRegressor

rf = RandomForestRegressor(
    n_estimators=300,
    max_depth=None,
    random_state=42,
    n_jobs=-1
)

rf.fit(X_train_scaled, y_train)
pred_rf = rf.predict(X_test_scaled)

# Evaluation
evaluate_regression(y_test, pred_rf, "Random Forest Regression")

# KNN REGRESSION

from sklearn.neighbors import KNeighborsRegressor

knn = KNeighborsRegressor(
    n_neighbors=7,
    weights="distance"
)

knn.fit(X_train_scaled, y_train)
pred_knn = knn.predict(X_test_scaled)

# Evaluation
evaluate_regression(y_test, pred_knn, "KNN Regression")

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

def evaluate_regression(y_true, y_pred, name):
    mae  = mean_absolute_error(y_true, y_pred)
    mse  = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2   = r2_score(y_true, y_pred)

    print(f"\n=== {name} ===")
    print(f"MAE  : {mae:.4f}")
    print(f"MSE  : {mse:.4f}")
    print(f"RMSE : {rmse:.4f}")
    print(f"R²   : {r2:.4f}")

evaluate_regression(y_test, pred_rf,  "Random Forest Regression")
evaluate_regression(y_test, pred_knn, "KNN Regression")

importances = rf.feature_importances_

fi_df = pd.DataFrame({
    "Feature": X.columns,
    "Importance": importances
}).sort_values("Importance", ascending=False)

print("\n=== FEATURE IMPORTANCE RF ===")
display(fi_df)

plt.figure(figsize=(6,4))
sns.barplot(data=fi_df, x="Importance", y="Feature", palette="Blues_r")
plt.title("Random Forest Feature Importance")
plt.show()

"""## Clustering"""

# K-MEANS CLUSTERING

from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

kmeans = KMeans(n_clusters=3, random_state=42)
ev_predic["Cluster_KMeans"] = kmeans.fit_predict(X)

sil_kmeans = silhouette_score(X, ev_predic["Cluster_KMeans"])
print("Silhouette Score (K-Means):", sil_kmeans)
print(ev_predic["Cluster_KMeans"].value_counts())

# GMM Clustering

from sklearn.mixture import GaussianMixture

gmm = GaussianMixture(n_components=3, random_state=42)
ev_predic["Cluster_GMM"] = gmm.fit_predict(X)

sil_gmm = silhouette_score(X, ev_predic["Cluster_GMM"])
print("Silhouette Score (GMM):", sil_gmm)
print(ev_predic["Cluster_GMM"].value_counts())

from sklearn.decomposition import PCA

pca = PCA(n_components=2)
components = pca.fit_transform(X)

plt.figure(figsize=(7,5))
sns.scatterplot(
    x=components[:,0],
    y=components[:,1],
    hue=ev_predic["Cluster_KMeans"],
    palette="Set2",
    s=40
)
plt.title("K-Means Clustering (PCA Visualization)")
plt.xlabel("PC1")
plt.ylabel("PC2")
plt.show()

plt.figure(figsize=(7,5))
sns.scatterplot(
    x=components[:,0],
    y=components[:,1],
    hue=ev_predic["Cluster_GMM"],
    palette="Set1",
    s=40
)
plt.title("GMM Clustering (PCA Visualization)")
plt.xlabel("PC1")
plt.ylabel("PC2")
plt.show()

# FEATURE ENGINEERING - HEALTH SCORE

df = ev_predic.copy()

min_c = df["Charge_Cycles"].min()
max_c = df["Charge_Cycles"].max()

print("Min/Max Charge_Cycles di dataset:", min_c, max_c)

def soh_from_cycle(c):
    c = float(c)

    if c <= 0:
        return 100.0

    if c <= min_c:
        return 100.0

    if c >= max_c:
        return 40.0

    ratio = (c - min_c) / (max_c - min_c)
    return 95.0 - ratio * 55.0

# hitung Health_Score hanya dari cycle
df["Health_Score"] = df["Charge_Cycles"].apply(soh_from_cycle)

# jaga-jaga; batasi 0–100
df["Health_Score"] = df["Health_Score"].clip(0, 100)

# cek hasil
print("NaN di Health_Score:", df["Health_Score"].isna().sum())

display(
    df[["Charge_Cycles", "Health_Score"]]
      .sort_values("Charge_Cycles")
      .head(40)
)

# simpan kembali ke ev_predic
ev_predic = df.reset_index(drop=True)

max_cycle_train = ev_predic["Charge_Cycles"].max()
min_cycle_train = ev_predic["Charge_Cycles"].min()
print("Cycle training range:", min_cycle_train, "sampai", max_cycle_train)

battery_features = [
    "Battery_Temperature",
    "Battery_Voltage",
    "Battery_Current",
    "Power_Consumption",
    "Charge_Cycles"
]

feature_median = ev_predic[battery_features].median()

synthetic_rows = []
for c in range(1, 21):
    row = feature_median.copy()
    row["Charge_Cycles"] = c
    synthetic_rows.append(row)

synthetic_df = pd.DataFrame(synthetic_rows)

synthetic_df["Health_Score"] = 100.0

print("Synthetic low-cycle data:")
display(synthetic_df.head())

ev_predic_aug = pd.concat([ev_predic, synthetic_df], ignore_index=True)

print("Contoh SoH setelah augment (cycle kecil):")
display(
    ev_predic_aug[["Charge_Cycles", "Health_Score"]]
    .sort_values("Charge_Cycles")
    .head(25)
)

# Pakai dataframe augmented ini untuk training
ev_predic = ev_predic_aug.copy()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

battery_features = [
    "Battery_Temperature",
    "Battery_Voltage",
    "Battery_Current",
    "Power_Consumption",
    "Charge_Cycles"
]

X = ev_predic[battery_features]
y = ev_predic["Health_Score"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

rf = RandomForestRegressor(
    n_estimators=300,
    random_state=42,
    n_jobs=-1
)
rf.fit(X_train_scaled, y_train)

def evaluate_regression(y_true, y_pred, name):
    mae  = mean_absolute_error(y_true, y_pred)
    mse  = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2   = r2_score(y_true, y_pred)
    print(f"\n=== {name} ===")
    print("MAE :", mae)
    print("MSE :", mse)
    print("RMSE:", rmse)
    print("R²  :", r2)

pred_rf = rf.predict(X_test_scaled)
evaluate_regression(y_test, pred_rf, "Random Forest Regression")

def predict_health_score():
    print("=== INPUT DATA EV ===")

    temp   = float(input("Battery Temperature : "))
    volt   = float(input("Battery Voltage     : "))
    curr   = float(input("Battery Current     : "))
    power  = float(input("Power Consumption   : "))
    cycles = float(input("Charge Cycles       : "))

    user_df = pd.DataFrame([{
        "Battery_Temperature": temp,
        "Battery_Voltage": volt,
        "Battery_Current": curr,
        "Power_Consumption": power,
        "Charge_Cycles": cycles
    }])

    print("\nData User:")
    display(user_df)

    # Scaling
    user_scaled = scaler.transform(user_df)

    # Predict with Random Forest
    pred = rf.predict(user_scaled)[0]

    print("\n=== HASIL PREDIKSI ===")
    print(f"SoH: {pred:.2f}%")

    # Status kesehatan
    if pred >= 80:
        kondisi = "SEHAT"
    elif pred >= 70:
        kondisi = "CUKUP SEHAT"
    else:
        kondisi = "BURUK"

    print("Status:", kondisi)

# Jalankan
predict_health_score()

def predict_health_score():
    print("=== INPUT DATA EV ===")

    temp   = float(input("Battery Temperature : "))
    volt   = float(input("Battery Voltage     : "))
    curr   = float(input("Battery Current     : "))
    power  = float(input("Power Consumption   : "))
    cycles = float(input("Charge Cycles       : "))

    user_df = pd.DataFrame([{
        "Battery_Temperature": temp,
        "Battery_Voltage": volt,
        "Battery_Current": curr,
        "Power_Consumption": power,
        "Charge_Cycles": cycles
    }])

    print("\nData User:")
    display(user_df)

    # Scaling
    user_scaled = scaler.transform(user_df)

    # Predict with Random Forest
    pred = rf.predict(user_scaled)[0]

    print("\n=== HASIL PREDIKSI ===")
    print(f"SoH: {pred:.2f}%")

    # Status kesehatan
    if pred >= 80:
        kondisi = "SEHAT"
    elif pred >= 70:
        kondisi = "CUKUP SEHAT"
    else:
        kondisi = "BURUK"

    print("Status:", kondisi)

# Jalankan
predict_health_score()

def predict_health_score():
    print("=== INPUT DATA EV ===")

    temp   = float(input("Battery Temperature : "))
    volt   = float(input("Battery Voltage     : "))
    curr   = float(input("Battery Current     : "))
    power  = float(input("Power Consumption   : "))
    cycles = float(input("Charge Cycles       : "))

    user_df = pd.DataFrame([{
        "Battery_Temperature": temp,
        "Battery_Voltage": volt,
        "Battery_Current": curr,
        "Power_Consumption": power,
        "Charge_Cycles": cycles
    }])

    print("\nData User:")
    display(user_df)

    # Scaling
    user_scaled = scaler.transform(user_df)

    # Predict with Random Forest
    pred = rf.predict(user_scaled)[0]

    print("\n=== HASIL PREDIKSI ===")
    print(f"SoH: {pred:.2f}%")

    # Status kesehatan
    if pred >= 80:
        kondisi = "SEHAT"
    elif pred >= 70:
        kondisi = "CUKUP SEHAT"
    else:
        kondisi = "BURUK"

    print("Status:", kondisi)

# Jalankan
predict_health_score()

def predict_health_score():
    print("=== INPUT DATA EV ===")

    temp   = float(input("Battery Temperature : "))
    volt   = float(input("Battery Voltage     : "))
    curr   = float(input("Battery Current     : "))
    power  = float(input("Power Consumption   : "))
    cycles = float(input("Charge Cycles       : "))

    user_df = pd.DataFrame([{
        "Battery_Temperature": temp,
        "Battery_Voltage": volt,
        "Battery_Current": curr,
        "Power_Consumption": power,
        "Charge_Cycles": cycles
    }])

    print("\nData User:")
    display(user_df)

    # Scaling
    user_scaled = scaler.transform(user_df)

    # Predict with Random Forest
    pred = rf.predict(user_scaled)[0]

    print("\n=== HASIL PREDIKSI ===")
    print(f"SoH: {pred:.2f}%")

    # Status kesehatan
    if pred >= 80:
        kondisi = "SEHAT"
    elif pred >= 70:
        kondisi = "CUKUP SEHAT"
    else:
        kondisi = "BURUK"

    print("Status:", kondisi)

# Jalankan
predict_health_score()

